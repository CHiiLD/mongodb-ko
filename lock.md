# 몽고디비의 락
C++로 개발된 MongoDB는 boost의 shared_mutex를 이용하여 락 시스템을 개발하였다. shared_mutex는 기본적으로 one writer many reader의 구조를 가지기 때문에 __MongoDB는 쓰기 락이 한 개만 존재__ 한다. 이러한 점은 MongoDB의 쓰기 연산에서 부하가 발생할 경우, 전체적인 시스템 부하를 야기할 수 있다.  하지만, 10gen에서는 쓰기 연산 속도가 매우 빠르기 때문에, MongoDB의 락이 부하를 발생시키지 않는다고 말한다. 사실 NoSQL은 트랜잭션이 없기 때문에 쓰기 연산에 대한 부하가 RDB 처럼 심하지 않다. 즉 __근본적인 쓰기만 수행하면 되기 때문에 매우 빠른 특징을 가진다. 또한 MongoDB는 1차적으로 메모리에 데이터를 쓰기 때문에 쓰기 연산 속도가 빠르다는 것이 보장된다.__

그렇다고, MongoDB의 락 시스템이 완전하다고 볼 수 없다. MongoDB는 쓰기 락을 시스템에 한 개를 유지하기 때문에, 아무래도 최대 쓰기 연산의 한계를 가진다. 이말은 클라이언트의 개수와는 상관 없이 최대 저장 속도가 락에 의해서 결정된다는 것이다. 이러한 문제점은 버전 2.2에서 컬랙션 별로 쓰기 락을 구현하여 어느정도 해소시켰다. 본 장에서는 이러한 MongoDB의 락 시스템에 대한 구조를 살펴보도록 한다.

## Boost의 shared_mutex
Boost에서는 일반 mutex의 기본 개념보다 좀 더 유연한 형태의 락을 설정할 수 있도록 __upgradable mutex__ 를 제공한다. 정확하게 표현하면, upgradable mutex는 mutex의 가능성을 판단하여 여러 개의 쓰레드가 동시에 락을 공유할 수 있도록 만든 기법이다. 이러한 기법을 __multi reader and single write__ 기술이라고 말한다. 읽기는 데이터 수정이 발생되지 않기 때문에 여러 개의 읽기 연산이 수행되어도 공유하는 데이터에 영향을 주지 않는다. 반면, 쓰기 연산은 공유하고 있는 데이터 수정이 발생하기 때문에 다른 쓰레드에서 읽기 또는 쓰기 연산과 충돌되어 데이터 일관성 문제가 발생한다. __즉 쓰기 연산은 배타적으로 락이 설정되어야 한다.__
Upgradable mutex는 이와 같이 읽기 연산은 쓰기 연산이 없는 동안, 아무런 제재 없이 읽기가 원활하게 이루어져야 하고, 쓰기 연산은 다른 쓰레드들의 읽기 또는 쓰기 연산이 자신의 쓰기 연산이 완료될 때까지 사용할 수 없도록 만들어 준다.

쓰기 연산을 수행하기 위한 절차를 생각해 보자. 쓰기 연산은 공유 데이터에 접근하기 위해 현재 공유 데이터를 사용하고 있는 쓰레드들이 있는지 판단한다. 만약 공유 데이터를 사용하고 있는 쓰레드가 있다면, 해당 쓰레드가 사용을 완료할 때까지 기다려야 한다. 자신을 제외한 모든 쓰레드가 공유 데이터의 사용을 완료하였다면, 대기 중이던 쓰기 연산은 배타적 락을 설정하여 다른 쓰레드들이 자신의 작업이 완료될 때까지 공유 데이터에 접근할 수 없도록 만든다.

반대로, 읽기 연산은 현재 공유 데이터를 액세스하기 위해 설정된 락들을 우선 조사하여야 한다. 공유 데이터에 설정된 락이 모두 읽기 락이라면 읽기 연산은 바로 공유 데이터에 접근할 수 있다. 하지만, 다른 쓰레드가 설정한 락이 쓰기 연산을 위한 배타적 락이라면, 읽기 연산은 배타적 락이 해제될 때까지 기다려야 한다.

Upgrade mutex는 쓰기 연산과 읽기 연산을 위해 3가지 유형의 락을 제공한다.

### 배타적 락 exclusive lock
배타적 락은 일반 mutex와 비숫하다. 임의의 한 쓰레드가 배타적 락을 획득했다면, 다른 쓰레드들은 어떠한 락도 이미 획득된 배타적 락이 해제되지 않는다면 획득할 수 없다. 임의의 쓰레드가 공유 또는 업그레이드 락을 가지고 있다면, 배타적 락을 획득하려는 쓰레드는 블록된다. __배타적 락은 데이터를 수정하기 위한 쓰레드에서 사용한다.__

### 공유 락 Sharable lock
임의의 쓰레드가 공유 락을 획득하였다면, 다른 쓰레드들은 공유 또는 업그레이드 락을 획득할 수 있다. 만약 다른 쓰레드가 배타적 락을 가지고 있다면, 공유 락을 획득하기 위해 시도하는 쓰레드는 블록된다. __공유 락은 데이터를 읽기 위한 쓰레드에서 사용된다.__

### 업그레이드 락 Upgradable lock
임의의 쓰레드가 업그레이드 락을 획득하였다면, 다른 쓰레드들은 공유 락을 획득할 수 있다. 만약 다른 쓰레드가 배타적 또는 업그레이드 락을 가지고 있다면, 업그레이드 락을 획득하려는 쓰레드는 블록된다. 업그레이드 락은 업그레이드 락을 설정한 쓰레드는 공유 락을 획득한 다른 쓰레드들이 락을 모두 해제하면 자동으로 배타적 락을 획득할 수 있도록 보장해 준다. 업그레이드 락은 일반적으로 쓰레드들이 읽기를 수행하지만, 데이터를 수행하기를 원하는 쓰레드에서 사용할 수 있다. 즉, __쓰기를 수행하는 쓰레드는 업그레이드 락을 사용하고, 읽기를 수행하는 쓰레드는 공유 락을 사용한다.__ 한가지 주의할 점은 업그레이드 락은 배타적 락과 같이 오로지 한 개의 쓰레드에서만 획득할 수 있다.

## 몽고디비의 락 시스템
앞 절에서도 논하였지만, MongoDB는 boost의 shared_mutex를 기반으로 락 시스템을 만들었다. 따라서, __읽기는 동시에 여러 쓰레드에서 동시에 수행되지만, 쓰기는 한 개의 쓰레드에서만 수행된다.__ 이러한 락 시스템은 다음과 같은 특징을 가진다.

+ 읽기 락은 쓰기 락이 설정되지 획득되지 않은 이상 병렬로 처리되지만, 쓰기 락이 획득되면 대기 상태로 빠진다. 쓰기 락이 해제되면 읽기 연산이 수행된다.
+ 쓰기 락은 읽기 락이 모두 해제된 상태에서 획득되며, 배타적 락을 형성한다.

따라서, __MongoDB는 쓰기와 읽기가 동시에 수행되지 않는다.__ 만약 시스템이 읽기를 많이 시도할 경우에는 쓰기가 블록 되고, 쓰기를 많이 수행할 경우는 읽기가 블록 된다.

![그림 3-1](./images/pic3-1.png)
[그림 3-1]은 MongoDB를 복제 시스템으로 구성하고 클라이언트가 읽기 연산을 수행하는 상태를 보여주고 있는 것으로 Slave_OK를 이용하여 master와 slave 모두 읽기가 가능한 상태를 나타낸다. 따라서 MongoDB는 master와 slave 모두 읽기 연산을 요청한다.  

(a)는 master와 slave 모두 락이 설정된 것이 없기 때문에 바로 읽기 연산 결과를 리턴 한다. __MongoDB 클라이언트는 master와 slave 둘 중에 하나가 먼저 리턴 된 값을 받아 그 결과를 응용에 전달한다.__  

(b)의 경우는 master와 slave 모두 읽기 락이 획득되어 있지만, __읽기 락이 공유 락이기 때문에 (a)와 같이 바로 연산의 결과 값을 리턴 한다.__

![그림 3-2](./images/pic3-2.png)
[그림 3-2]는 [그림 3-1]의 확장된 형태로 master와 slave에 쓰기 락이 구성될 때를 보여준다.  

(a)는 master에 쓰기 락이 설정된 것으로 클라이언트가 보낸 읽기 연산이 블록 된다. 따라서, 클라이언트는 slave로부터 전달 받은 읽기 연산 결과를 먼저 받게 되고, 응용에 해당 결과를 통보한다. __속도는 slave의 읽기 연산 속도와 동일하며, 쓰기 락에 따른 지연은 발생되지 않는다.__   

(b)는 조금 다른 상황이다. Master와 slave 모두 쓰기 락이 획득한 상태이다. __이러한 경우는 master와 slave로 보낸 읽기 연산 모두가 블록 되기 때문에, 읽기 연산이 지연된다.__ Slave의 쓰기 락은 Oplog의 동기화 또는 slave의 인덱스 재생성(foreground indexing) 때 발생된다. 만약 동기화 데이터가 많을 경우는 master의 락이 먼저 해제되어 master로 부터 읽기 연산의 결과를 받아 들일 것이다. 일반적으로 쓰기 연산은 벌크 삽입(bulk insert)인 경우를 제외하고 장시간을 요하지는 않는다. 따라서, 일반 slave의 Oplog 동기화를 위한 쓰기 락 보다 master의 쓰기 락이 먼저 해제 되는 것이 일반적이다.

## 몽고디비의 Global Lock
MongoDB의 global lock은 용어에 풍겨 나오는 이미지에 의해 여러 개의 노드로 구성된 MongoDB 시스템에서 유일하게 사용되는 전체 락 이라고 생각할 수 있지만, 이는 전체 락 이기 보다는 __MongoDB 시스템의 락 정보를 저장하고 있는 저장소이다.__ 저장하는 정보로는 현재 락 상태, 락 지속 여부, 현재 대기 중인 읽기 또는 쓰기 연산 수, 그리고 클라이언트 개수가 있다. [표 3]는 MongoDB의 serverStatus를 통해 취득할 수 있는 global lock의 항목을 보여준다.

[표 3] Global lock 항목

|항목|	내용|
|---|-------|
|globalLock.totalTime|	Global lock이 생성된 시간으로 시스템이 기동되고 난부터 수행중인 시간을 의미하다.(단위 : microseconds)|
|globalLock.lockTime|	Lock 지속시간을 나타내는 것으로, 프로세스가 기동하고 난 다음부터 현 시점까지 lock이 걸려있던 시간의 합을 의미한다.(단위 : microseconds)|
|globalLock.ratio|	lockTime / totalTime 의 값|
|globalLock.currentQueue.total|	currentQueue.readers + currentQueue.writers 의 값|
|globalLock.currentQueue.readers|	연산 중에서 lock이 걸린 읽기 연산의 개수|
|globalLock.currentQueue.writers|	연산 중에서 lock이 결린 쓰기 연산의 개수|
|globalLock.activeClients.total|	activeClients.readers + activeClients.writers 의 값|
|globalLock.activeClients.readers|	읽기 연산을 수행하고 있는 클라이언트의 개수|
|globalLock.activeClients.writers|	쓰기 연산을 수행하고 있는 클라이언트의 개수|

[표 3]의 값에서 주목하여야 할 값은 `lockTime`이다. `lockTime`은 MongoDB가 쓰기 락이 수행된 시간을 누적시킨 값으로, 값의 증가가 빨라지면 lockTime이 길어진다는 의미이다. 이 값이 길어지게 되는 원인은 여러 가지 발생할 수 있는데, 대부분 시스템 부하가 발생되어 lockTime이 길어진 것으로 보아야 한다. 한가지 분명한 사실은 쓰기 연산이 발생할 때마다 lockTime은 증가하며, __전체 시간 대비 lockTime이 증가하면 시스템 부하가 발생하였다고 예측할 수 있다.__

[표 3]의 `currentQueue`는 __MongoDB가 쓰기 락이 수행될 경우, 쓰기 락에 의해 대기 중인 연산을 의미한다.__ 명칭 큐로 설정되어 있어서 MongoDB가 큐에 연산을 넣고 해당 연산을 빼내어 처리한다고 판단할 수 있으나, 소스 코드상으로 볼 때, 연산을 요청한 클라이언트 리스트에서 해당 정보를 취득한다. 즉, 클라이언트가 요청할 때, 한 개의 쓰레드가 생성되는데, 이러한 쓰레드 리스트 중에서 현재 락이 걸린 연산들의 개수를 리턴 한다.

[표 3]의 `activeClients`는 __연산을 요청한 클라이언트의 개수를 저장__ 하는 것으로, 읽기 연산과 쓰기 연산을 요청한 클라이언트의 개수가 된다. 클라이언트의 한 개의 요청은 서버의 한 개의 쓰레드를 만들어 클라이언트의 요청이 할당된다. 서버에 쓰기 락이 활성화되지 않았다면, 서버가 생성한 쓰레드는 락이 걸리지 않는다. `cuurentQueue`와 `activeClients`는 모두 동일한 서버의 클라이언트 리스트에서 정보를 취득하지만, 임의의 클라이언트가 락이 걸려 있는지에 따라 데이터 값의 차이가 나타난다. 따라서, `currentQueue`의 값이 activeClients의 값 보다 클 수 없다.

MongoDB의 구성 요소인 mongos는 mongod와 달리 클라이언트의 역할을 담당하므로, `lockTime`, `currentQueue`, `activeClients`의 값이 나타나지 않는다. Global Lock은 서버 관점에서 클라이언트가 요청한 연산에 대한 락 상태를 보여주는 것이다. 따라서, [표 3]의 값은 mongod에서만 유효하다. 또한, [표 3]는 각각의 mongod에 따라 다른 값이 나타난다. MongoDB가 말하는 Global Lock은 한 개의 mongod 프로세스에서 발생하는 값을 의미한다. 만약 여러 개의 노드로 구성된 시스템에서의 Global Lock의 총합을 알고자 한다면, 각 mongod 프로세스에서 [표 3]의 globalLock 값을 취득한 뒤, 합쳐야 한다.

MongoDB는 메모리 데이터베이스의 성격을 가지고 있다. 따라서, 메모리에 데이터를 쓰는 시간 만큼의 쓰기 락이 주어진다. 이는 MongoDB의 일관성 정책이 NORMAL인 경우에 해당된다. 만약 일관성이 NORMAL이 아닌 SAFE라면 쓰기 락이 시간도 같이 올라간다.
